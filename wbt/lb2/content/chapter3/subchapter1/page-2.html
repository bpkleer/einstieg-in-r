---
title: "Piping"  # Titel der Seite
weight: 312 # Individuelles Gewicht 
menuTitle: "" # Falls Titel zulang ist, hier Kurztitel
tags: ["dplyr", "tidyverse", "piping"]  # Tags hiereinsetzen; Kurzwort, was auf der Seite passsiert
---



<p>{{% buttonGit href="https://gitlab.ub.uni-giessen.de/methoden-politik/einstieg-in-r/issues/new?issue[title]=" icon="fas fa-bug" %}} {{% /buttonGit %}}</p>
<p>{{% buttonGit href="mailto:?subject=Schau%20dir%20das%20mal%20an%3A%20" icon="fas fa-paper-plane" %}} {{% /buttonGit %}}</p>
<p>{{% buttonGit href="https://t.me/share/url?url=" icon="fab fa-telegram" %}} {{% /buttonGit %}}</p>
<p>{{% buttonGit href="https://api.whatsapp.com/send?text=" icon="fab fa-whatsapp" %}} {{% /buttonGit %}}</p>
<p>{{% buttonGit href="https://twitter.com/share?url=" icon="fab fa-twitter" %}} {{% /buttonGit %}}</p>
<p>{{% buttonGit href="https://www.facebook.com/sharer/sharer.php?u=" icon="fab fa-facebook" %}} {{% /buttonGit %}}</p>
<p>Nachdem nun die gängigsten Funktionen vorgestellt wurden, stellen wir vor, wie die Modularisierung bzw. das <strong>piping</strong> mit <code>dplyr</code> funktioniert. Wie schon oben genannt ist ein immenser Vorteil von <code>dplyr</code>, dass die Operationen <strong>gepipt</strong> werden, also in einzelne Bausteine aufgeteilt werden, die leicht nachzuvollziehen sind.</p>
<p>Über das <strong>Piping</strong> werden Datensätze oder <strong>tibbles</strong> aus vorherigen Operationen weitergegeben. Dies erfolgt über den Operator <code>%&gt;%</code>. Schauen wir ein erstes Beispiel an:</p>
<pre class="r"><code>pss &lt;- pss %&gt;%
  group_by(district) %&gt;%
  mutate(
    wkhtotMean = mean(
      wkhtot, 
      na.rm = TRUE
    )
  ) %&gt;%
  ungroup() </code></pre>
<p>Zuerst übergeben wir den geladenen Datensatz <code>pss</code>. Danach führen wir drei Operationen am Datensatz aus: <code>group_by()</code>, <code>mutate()</code> und <code>ungroup()</code>. Anschließend übergeben wir das bearbeitete Objekt mit den Zuordnungspfeilen <code>-&gt;</code> wieder an das ursprüngliche Objekt (wir überschreiben es also!).</p>
<p>Das Beispiel berechnet die durchschnittliche Arbeitszeit nach Distrikt und speichert dies in der neuen Variable <code>wkhtotMean</code>. Damit diese auch im Datensatz <code>pss</code> gespeichert wird, speichern wir diese Schritte mit dem Zuordnungspfeil wieder in das Objekt <code>pss</code>.</p>
<p>Da wir den Datensatz <em>übergeben</em>, müssen wir diesen in den einzelnen Operationen nicht mehr aufrufen. Die Piping-Operatoren muss man nicht immer händisch eingeben, sondern dieser wird automatisch mit <code>[Strg] + [Shift] + [M]</code> (Windows) bzw. <code>[Cmd] + [Shift] = [M]</code> (Mac) eingefügt.</p>
<p>Im nachfolgenden wollen wir verschiedene Vorbereitungsschritte mit <strong>piping</strong> durchführen.</p>
<div id="berechnen-und-recodieren-von-variablen" class="section level3">
<h3>Berechnen und Recodieren von Variablen</h3>
<p>Im Beispiel möchten wir nun eine neue Variable schaffen, die danach unterscheidet wie viel Vertrauen Personen in Politiker:innen haben (<code>trstplt</code>). So möchten wir zwischen geringem, mittlerem und hohem Vertrauen unterscheiden.</p>
<pre class="r"><code>pss &lt;- pss %&gt;%
  mutate(
    trstpltG = case_when(
      trstplt &lt;= 3 ~ &quot;low&quot;, 
      trstplt &gt; 3 &amp; trstplt &lt;= 6 ~ &quot;medium&quot;, 
      trstplt &gt; 6 ~ &quot;high&quot;
    )
  )
table(pss$trstpltG)</code></pre>
<pre><code>## 
##   high    low medium 
##    844   1275   2870</code></pre>
<p>Wenn man nun die neue Variable prüft, wird ersichtlich, dass die neue Variable als Typ <em>character</em> gespeichert wurde.</p>
<pre class="r"><code>str(pss$trstpltG)</code></pre>
<pre><code>##  chr [1:5000] &quot;medium&quot; &quot;medium&quot; &quot;medium&quot; &quot;medium&quot; &quot;medium&quot; &quot;low&quot; &quot;medium&quot; ...</code></pre>
<p>Dies kann ganz normal geändert werden, oder man schreibt es direkt ins <strong>Piping</strong>:</p>
<pre class="r"><code>pss &lt;- pss %&gt;%
  mutate(
    trstpltG = case_when(
      trstplt &lt;= 3 ~ &quot;low&quot;, 
      trstplt &gt; 3 &amp; trstplt &lt;= 6 ~ &quot;medium&quot;, 
      trstplt &gt; 6 ~ &quot;high&quot;
    )
  ) %&gt;% 
  mutate(trstpltG = factor(trstpltG)) #Schritt um von Character auf Factor zu kommen!

table(pss$trstpltG)</code></pre>
<pre><code>## 
##   high    low medium 
##    844   1275   2870</code></pre>
<pre class="r"><code>str(pss$trstpltG)</code></pre>
<pre><code>##  Factor w/ 3 levels &quot;high&quot;,&quot;low&quot;,&quot;medium&quot;: 3 3 3 3 3 2 3 3 2 3 ...</code></pre>
<p>Jetzt haben wir einen Faktor, aber noch ohne Ordnung, das können wir ebenfalls beheben:</p>
<pre class="r"><code>pss &lt;- pss %&gt;%
  mutate(
    trstpltG = case_when(
      trstplt &lt;= 3 ~ &quot;low&quot;, 
      trstplt &gt; 3 &amp; trstplt &lt;= 6 ~ &quot;medium&quot;, 
      trstplt &gt; 6 ~ &quot;high&quot;
    )
  ) %&gt;% 
  mutate(
    trstpltG = factor(
      trstpltG,
      ordered = TRUE, 
      levels = c(
        &quot;low&quot;, 
        &quot;medium&quot;, 
        &quot;high&quot;
      )
    ) 
  )

table(pss$trstpltG)</code></pre>
<pre><code>## 
##    low medium   high 
##   1275   2870    844</code></pre>
<pre class="r"><code>str(pss$trstpltG)</code></pre>
<pre><code>##  Ord.factor w/ 3 levels &quot;low&quot;&lt;&quot;medium&quot;&lt;..: 2 2 2 2 2 1 2 2 1 2 ...</code></pre>
<p>Etwas komplexer wäre folgende Aufgabe: Wir wollen nicht nur den Mittelwert der Arbeitszeit pro Distrikt berechnen, sondern die Abweichung einer Person im jeweiligen Distrikt vom Mittelwert des Distrikts!</p>
<pre class="r"><code>pss &lt;- pss %&gt;%
  group_by(district) %&gt;%
  mutate(
    wkhtotMean = mean(
      wkhtot, 
      na.rm = TRUE
    ),
    wkhtotDist = wkhtot - wkhtotMean  # wir fügen einfach diese einfache Berechnung des Abstands hinzu
  ) %&gt;%
  ungroup()

head(
  pss[, 
      c(
        &quot;district&quot;, 
        &quot;wkhtot&quot;,
        &quot;wkhtotMean&quot;,
        &quot;wkhtotDist&quot;
      )
  ]
)</code></pre>
<pre><code>## # A tibble: 6 × 4
##   district   wkhtot wkhtotMean wkhtotDist
##   &lt;fct&gt;       &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;
## 1 Distrikt 1     34       31.8       2.19
## 2 Distrikt 1     20       31.8     -11.8 
## 3 Distrikt 1     27       31.8      -4.81
## 4 Distrikt 1     30       31.8      -1.81
## 5 Distrikt 1     29       31.8      -2.81
## 6 Distrikt 1     30       31.8      -1.81</code></pre>
<p>Hier können wir jetzt auch einen Vorteil des modularen Prinzips erkennen. Wenn wir neue Variablen (hier <code>wkhtotMean</code>) berechnen und <em>weitergeben</em>, können wir diese in den folgenden Operationen direkt nutzen.</p>
<p>Alternativ könnten wir die Daten auch hierarchisch gruppieren nach Distrikt und Bildung (<code>edu</code>) und uns dann einfach die unterschiedlichen Mittelwerte mit <code>summarize()</code> ausgeben lassen:</p>
<pre class="r"><code>meansDistriktEdu &lt;- pss %&gt;%
  group_by(
    district,
    edu
  ) %&gt;%
  summarize(mean(wkhtot)) 

meansDistriktEdu</code></pre>
<pre><code>## # A tibble: 29 × 3
## # Groups:   district [5]
##    district   edu          `mean(wkhtot)`
##    &lt;fct&gt;      &lt;fct&gt;                 &lt;dbl&gt;
##  1 Distrikt 1 ES-ISCED I             33.8
##  2 Distrikt 1 ES-ISCED II            33.2
##  3 Distrikt 1 ES-ISCED III           32.4
##  4 Distrikt 1 ES-ISCED IV            31.8
##  5 Distrikt 1 ES-ISCED V             29.5
##  6 Distrikt 1 &lt;NA&gt;                   31.0
##  7 Distrikt 5 ES-ISCED I             34.1
##  8 Distrikt 5 ES-ISCED II            33.6
##  9 Distrikt 5 ES-ISCED III           33.2
## 10 Distrikt 5 ES-ISCED IV            32.2
## # ℹ 19 more rows</code></pre>
<p>Wir gehen jetzt nochmal einen Schritt zurück und schauen uns an, wie wir Datensätze teilen können. Dies ist relevant unter anderem in der Arbeit mit Sekundärdatensätze, da diese manchmal für mehr Personen erhoben wurden, als man selbst für seinen Forschungszweck benötigt.</p>
</div>
