---
title: "Datensätze zusammenführen (Fälle hinzufügen)"  # Titel der Seite
weight: 314  # Individuelles Gewicht 
menuTitle: "Fälle hinzufügen" # Falls Titel zulang ist, hier Kurztitel
tags: ["dplyr", "tidyverse", "datensatz"]  # Tags hiereinsetzen; Kurzwort, was auf der Seite passsiert
---



<p>{{% buttonGit href="https://gitlab.ub.uni-giessen.de/methoden-politik/einstieg-in-r/issues/new?issue[title]=" icon="fas fa-bug" %}} {{% /buttonGit %}}</p>
<p>{{% button href="https://twitter.com/intent/tweet" icon="fab fa-twitter" %}} {{% /button %}}</p>
<p>{{% buttonGit href="https://www.facebook.com/sharer/sharer.php?u=" icon="fab fa-facebook" %}} {{% /buttonGit %}}</p>
<p>Im nächsten Schritt nehmen wir nun an, dass die Datenerfassung getrennt nach Distrikt durchgeführt wurde und es somit fünf Teildatensätze gibt, die nun zu einem vollständigen Datensatz verbunden werden sollen. Dazu nutzen wir die Funktion <code>bind_rows()</code>. In unserem Beispiel haben alle fünf Teildatensätze genau die gleiche Anzahl an Variablen, die dazu auch noch genau gleich benannt sind! Mit dem Argument <code>.id</code> erstellen wir eine Variable names <code>"origin"</code>, die die Herkunft des Falles erfasst. Dies ist automatisch nummeriert. Mit <code>mutate()</code> machen wir daraus einen Faktor, der eine bessere Beschreibung beinhaltet (<em>process1</em>, <em>process2</em>, <em>process3</em>, <em>process4</em>, <em>process5</em>)</p>
<pre class="r"><code>pssAll &lt;- pss1 %&gt;%
  bind_rows(
    list(
      pss5,
      pss7, 
      pss10, 
      pss12
    ), 
    .id = &quot;origin&quot;
  ) %&gt;%
  mutate(
    origin = factor(
      origin, 
      labels = c(
        &quot;process1&quot;, 
        &quot;process2&quot;, 
        &quot;process3&quot;, 
        &quot;process4&quot;,
        &quot;process5&quot;
      )
    )
  )

table(pssAll$origin)</code></pre>
<pre><code>## 
## process1 process2 process3 process4 process5 
##     1000     1000     1000     1000     1000</code></pre>
<pre class="r"><code>head(pssAll$origin)</code></pre>
<pre><code>## [1] process1 process1 process1 process1 process1 process1
## Levels: process1 process2 process3 process4 process5</code></pre>
<p>Wir haben hier jetzt also aus fünf Teildatensätzen einen gesamten Datensatz erstellt, der alle Fälle der fünf Teildatensätze enthält. Wichtig, in diesem Fall waren alle Variablennamen gleich!</p>
<p>Nun probieren wir einmal aus, was passiert, wenn es zum Beispiel in einem Teildatensatz einen Typo gibt. Zuerst erstellen wir dazu einfach zwei neue Datensätze, die jeweils nur 3 Fälle inkludieren, und unterschiedliche Variablen.</p>
<pre class="r"><code>pssA &lt;- pss[1:3, 2:3]

District &lt;- c(
  &quot;Distrikt 1&quot;, 
  &quot;Distrikt 5&quot;,
  &quot;Distrikt 7&quot;
)

gndr &lt;- c(
  &quot;male&quot;,
  &quot;female&quot;,
  &quot;female&quot;
)

pssB &lt;- data.frame(
  District, 
  gndr
)

head(pssA)</code></pre>
<pre><code>##     district gndr
## 1 Distrikt 1 male
## 2 Distrikt 1 male
## 3 Distrikt 1 male</code></pre>
<pre class="r"><code>head(pssB)</code></pre>
<pre><code>##     District   gndr
## 1 Distrikt 1   male
## 2 Distrikt 5 female
## 3 Distrikt 7 female</code></pre>
<p>Wir haben also in beiden Datensätzen die zwei Variablen, die Distrikt und Geschlecht angeben. Im Datensatz <code>pssB</code> ist aber die Variable des Distrikts anders geschrieben. Probieren wir <code>bind_rows()</code> aus.</p>
<pre class="r"><code>pssTest &lt;- pssA %&gt;% 
  bind_rows(pssB)

pssTest</code></pre>
<pre><code>##     district   gndr   District
## 1 Distrikt 1   male       &lt;NA&gt;
## 2 Distrikt 1   male       &lt;NA&gt;
## 3 Distrikt 1   male       &lt;NA&gt;
## 4       &lt;NA&gt;   male Distrikt 1
## 5       &lt;NA&gt; female Distrikt 5
## 6       &lt;NA&gt; female Distrikt 7</code></pre>
<p>Da die Variablennamen nicht genau gleich sind, werden nun drei Variablen geschaffen: <code>district</code>, <code>gndr</code> und <code>District</code>. Wo die Variable nicht vorliegt, werden automatisch <code>NAs</code> erzeugt. Dies ist vorteilhaft, kann aber auch frickelig werden, wenn bei der Datensatzerstellung nicht streng nach einem Codenamen-Schema gearbeitet wurde. <strong>Lösung</strong>: Im Vorfeld Variablen abklären und umbenennen. Andernfalls kann man <code>full_join()</code> nutzen.</p>
<div id="datensätze-zusammenführen-unterschiedliche-spaltennamen" class="section level3">
<h3>Datensätze zusammenführen (unterschiedliche Spaltennamen)</h3>
<p>Dieser Ansatz ist nicht weniger aufwändig, als das Umbenennen von Spaltennamen, bietet aber dennoch eine Alternative. Mit <code>full_join()</code> kombinieren wir zwei Datensätze und können im Argument <code>by</code> angeben, welche Spalten jeweils denselben Inhalt haben. Schreibaufwand hierbei ist, dass gleiche Spaltennamen auch aufgeführt werden müssen, da ansonsten (hier im Beispiel) die Variablen <code>gndr.x</code> und <code>gndr.y</code> gebildet werden. Dies liegt daran, da <code>full_join()</code> eigentlich dafür gedacht ist, neue/zusätzliche Variablen hinzuzufügen.</p>
<p>In unserem Beispiel würden wir also angeben, dass aus Datensatz <code>pssA</code> die Spalte <code>district</code> gleich der Spalte <code>District</code> aus dem Datensatz <code>pssB</code> ist. Gleiches gilt für die <code>gndr</code> Variable.</p>
<pre class="r"><code>pssTest2 &lt;- pssA %&gt;% 
  full_join(
    pssB,
    by = c(
      &quot;district&quot; = &quot;District&quot;, 
      &quot;gndr&quot; = &quot;gndr&quot;
    )
  )

head(pssTest2)</code></pre>
<pre><code>##     district   gndr
## 1 Distrikt 1   male
## 2 Distrikt 1   male
## 3 Distrikt 1   male
## 4 Distrikt 5 female
## 5 Distrikt 7 female</code></pre>
<p>So klappt es dann auch mit unterschiedlichen Variablennamen!</p>
</div>
